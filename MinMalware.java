// Time Complexity : O(n^2) check for all nodes.
// Space Complexity : O(n), for groups array

// Did this code successfully run on Leetcode : yes

// Approach:  make nodes part of an island and check how many nodes can be saved in each island if we remove the malware affected node.

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;

        int[] groupNums = new int[n];
        Arrays.fill(groupNums,-1);

        int g=0; 
        for(int i = 0 ; i < n ; i++){ //O(n^2) check for all nodes.
            if(groupNums[i] == -1){
                dfs(graph, groupNums,i,g);
                g++;
            }
        }


        int[] nums = new int[g]; // nodes in each group
        for(int i  = 0; i < n ; i++){
            int group = groupNums[i];
            nums[group]++;
        }

        int[] affected = new int[g]; // nodes affected in each group

        for(int i : initial){
            affected[groupNums[i]]++;
        }

        int result = Integer.MAX_VALUE;
        int saved = 0 ;
        for(int i :  initial){
            int gr = groupNums[i];
            if(affected[gr] == 1){ //any group have affected greater than 1 can not be saved
                int s = nums[gr]--;
                if(s  > saved){
                    result = i;
                    saved = s;
                }
                else if(s == saved){
                    result = Math.min(result,i);
                }
            }
        }

        if(result == Integer.MAX_VALUE){
            for(int i : initial){
                result = Math.min(result,i);
            }
        }

        return result;
    }

    private void dfs(int[][] graph, int[] groupNums, int i, int group){
        //base
        if(groupNums[i] != -1) return;

        //logic
        groupNums[i] = group;

        for(int j = 0 ; j < graph.length ; j++){
            if(graph[i][j] == 1){ //connection
                dfs(graph,groupNums, j,group);
            }
        }
    }
}